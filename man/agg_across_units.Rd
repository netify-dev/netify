% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_across_units.R
\name{agg_across_units}
\alias{agg_across_units}
\alias{aggregate_dyad}
\alias{dyad_aggregate}
\alias{agg_dyad}
\alias{dyad_agg}
\title{Aggregate dyadic data by actor pairs}
\usage{
agg_across_units(
  dyad_data,
  actor1,
  actor2,
  time = NULL,
  weight,
  symmetric,
  ignore_missing = TRUE
)

aggregate_dyad(
  dyad_data,
  actor1,
  actor2,
  time = NULL,
  weight,
  symmetric,
  ignore_missing = TRUE
)

dyad_aggregate(
  dyad_data,
  actor1,
  actor2,
  time = NULL,
  weight,
  symmetric,
  ignore_missing = TRUE
)

agg_dyad(
  dyad_data,
  actor1,
  actor2,
  time = NULL,
  weight,
  symmetric,
  ignore_missing = TRUE
)

dyad_agg(
  dyad_data,
  actor1,
  actor2,
  time = NULL,
  weight,
  symmetric,
  ignore_missing = TRUE
)
}
\arguments{
\item{dyad_data}{A data frame containing dyadic observations with at least
columns for two actors and a weight variable.}

\item{actor1}{Character string specifying the column name for the first actor
in each dyad.}

\item{actor2}{Character string specifying the column name for the second actor
in each dyad.}

\item{time}{Character string specifying the column name for time periods.
If NULL (default), aggregation is performed across all time periods.}

\item{weight}{Character string specifying the column name containing values
to be aggregated (summed) for each unique actor pair.}

\item{symmetric}{Logical. If TRUE, treats dyads as undirected (i.e., the dyad
A-B is treated as identical to B-A). If FALSE, treats dyads as directed
(i.e., A-B is distinct from B-A).}

\item{ignore_missing}{Logical. If TRUE (default), missing values in the weight
variable are ignored during aggregation. If FALSE, any dyad containing a
missing value will result in NA for that aggregated dyad.}
}
\value{
A data frame with unique actor pairs (and time periods if specified)
and their aggregated weight values. The output will have columns:
\itemize{
\item \code{actor1}: First actor in each dyad
\item \code{actor2}: Second actor in each dyad
\item \code{time}: Time period (if time parameter was specified)
\item \code{weight}: Aggregated (summed) values for each unique dyad
}
}
\description{
agg_across_units\verb{(also available as}aggregate_dyad\verb{, }dyad_aggregate\verb{,  }agg_dyad\verb{, and }dyad_agg`) aggregates
dyadic (pairwise) data by summing values across
repeated actor pairs. This function is useful for consolidating multiple
interactions between the same pair of actors into a single summary value,
such as combining multiple trade transactions or communication events.
}
\details{
For symmetric networks, the function uses an efficient aggregation method that:
\enumerate{
\item Creates symmetric identifiers for each dyad (where A-B = B-A)
\item Aggregates values by these identifiers
\item Expands the results back to directed format for consistency
}

For asymmetric networks, standard aggregation is performed treating each
directed dyad separately.
}
\examples{
# Create example dyadic trade data
trade_data <- data.frame(
  exporter = c("USA", "USA", "China", "China", "USA", "China"),
  importer = c("China", "China", "USA", "USA", "UK", "UK"),
  year = c(2020, 2020, 2020, 2021, 2021, 2021),
  trade_value = c(100, 50, 75, 80, 120, 90)
)

# Aggregate directed trade flows by year
agg_trade <- agg_across_units(
  dyad_data = trade_data,
  actor1 = "exporter", 
  actor2 = "importer",
  time = "year",
  weight = "trade_value",
  symmetric = FALSE
)
print(agg_trade)

# Aggregate as undirected trade (total trade between countries)
total_trade <- agg_across_units(
  dyad_data = trade_data,
  actor1 = "exporter",
  actor2 = "importer", 
  time = "year",
  weight = "trade_value",
  symmetric = TRUE
)
print(total_trade)

# Aggregate across all years
all_years_trade <- agg_across_units(
  dyad_data = trade_data,
  actor1 = "exporter",
  actor2 = "importer",
  time = NULL,  # Aggregate across all time periods
  weight = "trade_value",
  symmetric = FALSE
)
print(all_years_trade)

}
\author{
Shahryar Minhas
}
