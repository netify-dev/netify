% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_adjacency.R
\name{get_adjacency}
\alias{get_adjacency}
\title{Converts a dyadic data into a network in various formats}
\usage{
get_adjacency(
  dyad_data,
  actor1 = NULL,
  actor2 = NULL,
  symmetric = TRUE,
  mode = "unipartite",
  weight = NULL,
  sum_dyads = FALSE,
  diag_to_NA = TRUE,
  missing_to_zero = TRUE
)
}
\arguments{
\item{dyad_data}{a dyadic dataframe (or a tibble)}

\item{actor1}{character: name of the actor 1 in dyad_data}

\item{actor2}{character: name of the actor 2 in dyad_data}

\item{symmetric}{logical: whether ties are symmetric, default is TRUE}

\item{mode}{character: whether the network is unipartite or bipartite, default is unipartite}

\item{weight}{character: name of the weighted edges variable, default is NULL}

\item{sum_dyads}{logical: whether to sum up the \code{weight} value when there exists repeating dyads within the dataset}

\item{diag_to_NA}{logical: whether diagonals should be set to NA, default is TRUE}

\item{missing_to_zero}{logical: whether missing values should be set to zero, default is TRUE}
}
\value{
an adjacency matrix of class netify
}
\description{
\code{get_adjacency} takes in a dyadic dataset and outputs an adjacency matrix representation.
}
\examples{

# load example directed event data from ICEWS
# this data comes in the form of a dyadic
# dataframe where all dyad pairs are listed
data(icews)

# subset to a particular year
icews <- icews[icews$year=='2010', ]

# generate a cross sectional, directed, and weighted network
# where the weights are verbCoop
icews_verbCoop <- get_adjacency(
  dyad_data=icews, actor1='i', actor2='j',
  symmetric=FALSE, weight='verbCoop' )
# generate a cross sectional, directed and weighted network
# where the weights are matlConf
icews_matlConf <- get_adjacency(
  dyad_data=icews, actor1='i', actor2='j',
  symmetric=FALSE, weight='matlConf' )

# another example using cow data
# gathered from the peacesciencer package
library(peacesciencer)
library(dplyr)

# create dyadic data set over time
cow_dyads <- create_dyadyears( 
    subset_years = c(1992:2014)
    ) \%>\%
    # add mids
    add_cow_mids()

# the cross-sections refer to the number of 
# conflict onsets between dyads during
# the time period of the data 
mid_network <- netify(
  cow_dyads,
  actor1='ccode1', actor2='ccode2',
  weight='cowmidonset', 
  sum_dyads=TRUE, symmetric=TRUE,
  diag_to_NA=TRUE, missing_to_zero=TRUE)
mid_network 

# now lets say that we just want to 
# see whether any conflict onset
# occurred between a dyad during 
# this period and generate
# a network object that represents this

# to generate this we need to first subset
# the raw data into an edge list like format
# this only involves subsetting the variable
# that you are using to represent edges to be
# a value above zero
cow_dyad_conflict_onset <- cow_dyads \%>\%
    filter(
        cowmidonset > 0
    )

# then we use the netify function and 
# we no longer supply a weight, since the
# dyads themselves are giving information about
# edges that occurred and in addition we leave
# sum_dyads as FALSE
any_mid_network <- netify(
  cow_dyad_conflict_onset,
  actor1='ccode1', actor2='ccode2',
  sum_dyads=FALSE, symmetric=TRUE,
  diag_to_NA=TRUE, missing_to_zero=TRUE)
mid_network

}
\author{
Ha Eun Choi, Cassy Dorff, Colin Henry, Shahryar Minhas
}
