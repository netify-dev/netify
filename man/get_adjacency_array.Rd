% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_adjacency_array.R
\name{get_adjacency_array}
\alias{get_adjacency_array}
\title{Create a netify array from longitudinal dyadic data}
\usage{
get_adjacency_array(
  dyad_data,
  actor1 = NULL,
  actor2 = NULL,
  time = NULL,
  symmetric = TRUE,
  mode = "unipartite",
  weight = NULL,
  sum_dyads = FALSE,
  diag_to_NA = TRUE,
  missing_to_zero = TRUE
)
}
\arguments{
\item{dyad_data}{A data.frame containing longitudinal dyadic observations. Will
be coerced to data.frame if a tibble or data.table is provided.}

\item{actor1}{Character string specifying the column name for the first actor
in each dyad.}

\item{actor2}{Character string specifying the column name for the second actor
in each dyad.}

\item{time}{Character string specifying the column name for time periods.}

\item{symmetric}{Logical. If TRUE (default), treats the network as undirected
(i.e., edges have no direction). If FALSE, treats the network as directed.}

\item{mode}{Character string specifying network structure. Options are:
\itemize{
\item \code{"unipartite"}: One set of actors (default)
\item \code{"bipartite"}: Two distinct sets of actors
}}

\item{weight}{Character string specifying the column name containing edge weights.
If NULL (default), edges are treated as unweighted (binary).}

\item{sum_dyads}{Logical. If TRUE, sums weight values when multiple edges exist
between the same actor pair in the same time period. If FALSE (default), uses
the last observed value.}

\item{diag_to_NA}{Logical. If TRUE (default), sets diagonal values (self-loops)
to NA. Automatically set to FALSE for bipartite networks.}

\item{missing_to_zero}{Logical. If TRUE (default), treats missing edges as zeros.
If FALSE, missing edges remain as NA.}
}
\value{
A three-dimensional array of class "netify" (a netify array) with:
\itemize{
\item \strong{Dimensions}: \code{[n_actors × n_actors × n_time]} for unipartite
networks or \code{[n_actors1 × n_actors2 × n_time]} for bipartite networks
\item \strong{Class}: "netify" - this is a full netify object compatible
with all netify functions
\item \strong{Attributes}: Extensive metadata including network properties,
actor information, and processing parameters
}

The returned object is a netify array that can be used with all netify
functions such as \code{summary()}, \code{plot()}, \code{to_igraph()}, etc.
}
\description{
\code{get_adjacency_array} converts longitudinal dyadic data into a three-dimensional
netify array where the first two dimensions represent actors and the third
dimension represents time periods. This function creates an array of class
"netify" and should only be used when actor composition remains constant
across all time periods.
}
\details{
\strong{Note on usage:}

While this function is exported and available for direct use, the primary and
recommended way to create netify arrays from longitudinal dyadic data is through
the \code{netify()} function. The \code{netify()} function:
\itemize{
\item Automatically determines whether to create an array or list structure
\item Handles time-varying actor composition
\item Provides more comprehensive data validation
\item Offers a unified interface for all types of network data
}

Use \code{get_adjacency_array()} directly only when you specifically need low-level
control over array creation and are certain your actors remain constant across
time.
}
\examples{
# Load example data
data(icews)

# Create a netify array (longitudinal directed network)
# with material conflict as edge weights
icews_array <- get_adjacency_array(
    dyad_data = icews,
    actor1 = "i",
    actor2 = "j",
    time = "year",
    symmetric = FALSE,
    weight = "matlConf"
)

# Verify it's a netify object
class(icews_array) # "netify"

# Check dimensions
dim(icews_array) # [n_actors, n_actors, n_years]

# Access specific time period
icews_2010 <- icews_array[, , "2010"]

}
\author{
Cassy Dorff, Ha Eun Choi, Shahryar Minhas
}
