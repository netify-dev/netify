% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/netify.R
\name{netify}
\alias{netify}
\title{Create network object from various data types}
\usage{
netify(
  input,
  actor1 = NULL,
  actor2 = NULL,
  time = NULL,
  symmetric = TRUE,
  mode = "unipartite",
  weight = NULL,
  sum_dyads = FALSE,
  actor_time_uniform = TRUE,
  actor_pds = NULL,
  diag_to_NA = TRUE,
  missing_to_zero = TRUE,
  output_format = NULL,
  nodal_vars = NULL,
  dyad_vars = NULL,
  dyad_vars_symmetric = rep(symmetric, length(dyad_vars)),
  input_type = c("auto", "dyad_df", "netify_obj"),
  ...
)
}
\arguments{
\item{input}{data object to netify. Can be:
\itemize{
\item A data.frame (or tibble/data.table) with dyadic data
\item A matrix representing an adjacency matrix
\item A 3D array representing longitudinal networks
\item A list of matrices representing longitudinal networks
\item An igraph object
\item A network object (from the network package)
\item A list of igraph or network objects
}}

\item{actor1}{character: name of the actor 1 variable in the data (required
for data.frame inputs)}

\item{actor2}{character: name of the actor 2 variable in the data (required
for data.frame inputs)}

\item{time}{character: name of the time variable in the data. Can contain
numeric, Date, POSIXct/POSIXlt, or character values. Non-numeric types
will be converted to numeric indices while preserving original labels.
If no time is provided then a cross-sectional network will be created.}

\item{symmetric}{logical: whether ties are symmetric, default is TRUE}

\item{mode}{character: whether the network is unipartite or bipartite, default is unipartite}

\item{weight}{character: name of the weighted edge variable in
the data, default is NULL}

\item{sum_dyads}{logical: whether to sum up the \code{weight} value when there exists repeating dyads}

\item{actor_time_uniform}{logical: whether to assume
actors are the same across the full time series observed in the data
TRUE means that actors are the same across the full time
series observed in the data and the outputted netify object will
be in an array format.
FALSE means that actors come in and out of the observed data and
their "existence" should be determined by the data, meaning that
their first year of existence will be determined by the time point
of their first event and their last year of existence by the
time point of their last event. Outputted netify object will be
in a list format.}

\item{actor_pds}{a data.frame indicating start and end time point for every
actor, this can be created using \code{get_actor_time_info}, unless provided this will
estimated for the user based on their choice of \code{actor_time_uniform}}

\item{diag_to_NA}{logical: whether diagonals should be set to NA, default is TRUE}

\item{missing_to_zero}{logical: whether missing values should be set to zero, default is TRUE}

\item{output_format}{character: "cross_sec", "longit_array", or
"longit_list". If not specified and time is NULL then output_format
will be "cross_sec" and if time is specified then output_format
will default to "longit_list". Only applies to data.frame inputs.}

\item{nodal_vars}{character vector: names of the nodal variables in the input
that should be added as attributes to the netify object (for data.frame inputs)}

\item{dyad_vars}{character vector: names of the dyadic variables in the input
that should be added as attributes to the netify object (for data.frame inputs)}

\item{dyad_vars_symmetric}{logical vector: whether ties are symmetric, default is
to use the same choice as the symmetric argument}

\item{input_type}{character: force specific input type interpretation.
Options are "auto" (default), "dyad_df", or "netify_obj". Use "dyad_df"
to force data.frame interpretation or "netify_obj" to force matrix/array/
igraph/network interpretation.}

\item{...}{additional arguments passed to \code{to_netify} when processing network objects}
}
\value{
a netify object
}
\description{
This function takes in various types of network data (dyadic datasets, matrices,
arrays, lists, igraph objects, or network objects) and outputs a netify object.
}
\examples{

# load example directed event data from ICEWS
# this data comes in the form of a dyadic
# dataframe where all dyad pairs are listed
data(icews)

# From a data.frame: generate a longitudional, directed and weighted network
# where the weights are matlConf
icews_matlConf <- netify(
    input=icews,
    actor1='i', actor2='j', time='year',
    symmetric=FALSE, weight='matlConf')

# From a matrix
adj_matrix <- matrix(rbinom(100, 1, 0.3), 10, 10)
net_from_matrix <- netify(adj_matrix)

# From an igraph object
\dontrun{
library(igraph)
g <- sample_gnp(10, 0.3)
net_from_igraph <- netify(g)
}

}
\author{
Ha Eun Choi, Cassy Dorff, Colin Henry, Shahryar Minhas
}
