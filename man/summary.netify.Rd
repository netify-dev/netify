% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summary.netify.R
\name{summary.netify}
\alias{summary.netify}
\title{Summary method to get graph level statistics for netify objects}
\usage{
\method{summary}{netify}(object, ...)
}
\arguments{
\item{object}{An object of class netify, which should have been created using the function \code{get_adjacency}. This object contains the network data structured for analysis.}

\item{...}{Additional parameters which can include user-defined statistical functions. These functions should take a matrix as input and return a scalar value. They will be applied to each network slice individually if the netify object represents longitudinal data.
\itemize{
\item \code{other_stats}: A named list of functions that take a matrix and return additional actor-level statistics to be included in the output. Each function should accept a matrix as input and return a vector or single value per actor. This allows for the inclusion of custom metrics in the summary output.
}}
}
\value{
A data frame where each row represents the network-level statistics for a single network or a single time point in a longitudinal study. Depending on the network type and data attributes, the columns can include:
\itemize{
\item \code{num_actors}: Number of actors in the network - for bipartite networks number of row and column actors are reported separately.
\item \code{density}: The proportion of possible connections that are actual connections within the network.
\item \code{num_edges}: The total number of edges in the network.
\item \code{mean_edge_weight}: The average weight of edges in the network, provided only for weighted networks.
\item \code{sd_edge_weight}: The standard deviation of edge weights in the network, provided only for weighted networks.
\item \code{prop_edges_missing}: The proportion of potential edges that are missing or marked as NA.
\item \code{min_edge_value} and \code{max_edge_value}: The minimum and maximum edge weights observed in the network, provided only for weighted networks.
\item \code{competition_row} and \code{competition_col} (defaults to \code{competition} for undirected networks): Measures network competitiveness using the Herfindahl-Hirschman Index (HHI), defined as \eqn{1 - \sum_{i=1}^{n} (s_i)^2}, where \eqn{s_i} is the proportion of interactions by actor \eqn{i} and \eqn{n} is the total number of actors. The index ranges from 1/n (indicating high diversity and competitive interaction across actors) to 1 (one actor dominates all interactions). Refer to Dorff, Gallop, & Minhas (2023) for an application of this measure in conflict networks.
\item \code{sd_of_row_means} and \code{sd_of_col_means}: Standard deviations of the sending and receiving effects (row and column means).
\item \code{covar_of_row_col_means}: The covariance between sending and receiving effects, calculated for unipartite networks.
\item \code{reciprocity}: The reciprocity of the network, defined as the correlation between the adjacency matrix and its transpose, calculated for unipartite networks.
\item \code{transitivity}: The overall transitivity or clustering coefficient of the network, reflecting the likelihood that two neighbors of a node are connected.
}
}
\description{
\code{summary.netify} processes a netify object to calculate and return a data frame of graph-level statistics. This function is designed to work with both cross-sectional and longitudinal netify data structures, providing a comprehensive overview of network characteristics such as density, reciprocity, and standard deviations of sending and receiving effects.
}
\details{
This function simplifies the process of extracting key network statistics across potentially multiple networks within a netify object. It is capable of handling both weighted and unweighted networks and can adjust its calculations based on the nature of the network data (cross-sectional vs. longitudinal).
}
\examples{

# load icews data
data(icews)

# create netlet
netlet = netify(
    dyad_data=icews, actor1='i', actor2='j',
    time = 'year', symmetric=FALSE, weight='verbCoop' )

# calculate default summary stats
summ_graph = summary(netlet)
head(summ_graph)

# add custom summary stat
spinglass_ig = function(mat){
    g = prep_for_igraph(mat)
    comm = igraph::cluster_spinglass(g)
    num_comm = length(comm$csize)
    return( c(
        num_comm=num_comm,
        comm_modul = comm$modularity
    ) )
}

# since calculating communities can be intensive
# lets take subset of time periods
sub_net = subset_netlet(netlet, when_to_subset = as.character(2013:2014))

# feed custom summary stat into summary
summary(sub_net, 
    other_stats=list(spinglass_ig=spinglass_ig)) 

}
\author{
Cassy Dorff, Shahryar Minhas
}
