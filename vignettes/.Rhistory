event_mat
peek(igo_network, 10)
peek(event_mat, 10)
igo_dyads_slice <- igo_dyads %>%
filter(year == 2010)
# time slice
igo_network_2010 <- netify(
igo_dyads_slice,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
event_mat_2010
igo_network_2010
igo_network_time <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=TRUE,
weight='dyadigos', symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time
# use the index location
peek(event_mat_time, when_to_peek = 2)
# use the index location
peek(event_mat_time, when_to_peek = 2)
# use the index location
peek(igo_network_time, when_to_peek = 2)
igo_network_time_actors <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=FALSE,
weight="dyadigos", symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time_actors
is.list(igo_network_time_actors)
head(lapply(igo_network_time_actors, dim))
# cross sectional peek
peek(igo_network)
# cross sectional peek
peek(igo_network_2010)
# changing actors peek
peek(igo_network_time_actors, when_to_peek = 5, what_to_peek = 10 )
sum_event_mat <- summary(igo_network)
igo_network <- netify(
igo_dyads,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network
sum_event_mat <- summary(igo_network)
sum_event_mat
transitivity = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
trans <- sum(diag(E%*%t(E)%*%E))/( sum(diag(D%*%t(D)%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(trans)
}
cycles = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
cycles <- sum(diag(E%*%E%*%E))/( sum(diag(D%*%D%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(cycles)
}
sum_event_mat <- summary(event_mat, cycles=cycles, transitivity=transitivity)
sum_event_mat
network_sum <- summary_actor(igo_network)
network_sum
nets_time_sum <- summary(igo_network_time)
library(ggplot2)
plot_networkStats(nets_time_sum, longitudinal = TRUE, net_stat=c("sdSendEff", "sdRecEff")) +
labs(title = "Network-level Statistics") +
theme_bw()
# compare USA (2), China (710), Russia (365)
plot_actorStats(network_sum, longitudinal=FALSE, net_stat=c('average_degree_in','average_degree_out'),
actor_names=c('2', '710', '365'), toplist_n=NULL)
plot_actorStats(network_sum, longitudinal=FALSE, net_stat='average_degree_in', toplist_n=10)
# select actors for graphing, regenerate data to do so?
# what is the easiest way to subset a netlet?
igraph_obj <- prep_for_igraph(igo_network_2010)
igraph_obj
rm_iso = which(degree(igraph_obj)==0)
igraph_obj = delete.vertices(igraph_obj, rm_iso)
graph_attr(igraph_obj, "layout") <- layout_in_circle
plot(igraph_obj, edge.arrow.size=.1,vertex.label=NA)
graph_attr(igraph_obj, "layout") <- layout.random
# select actors for graphing, regenerate data to do so?
# what is the easiest way to subset a netlet?
igraph_obj <- prep_for_igraph(igo_network_2010)
igraph_obj
rm_iso = which(degree(igraph_obj)==0)
igraph_obj = delete.vertices(igraph_obj, rm_iso)
graph_attr(igraph_obj, "layout") <- layout.random
plot(igraph_obj, edge.arrow.size=.1,vertex.label=NA)
igraph_obj
igo_network_2010
igo_network_2010[1:20, 1:20]
test <- igo_network_2010[1:20, 1:20]
class(test)
# select actors for graphing, regenerate data to do so (and remake netlet)?
# what is the easiest way to subset a netlet?
# test <- igo_network_2010[1:20, 1:20]
# class(test)
igraph_obj <- prep_for_igraph(igo_network_2010)
igraph_obj
rm_iso = which(degree(igraph_obj)==0)
igraph_obj = delete.vertices(igraph_obj, rm_iso)
graph_attr(igraph_obj, "layout") <- layout.random
plot(igraph_obj, edge.arrow.size=.1,vertex.label=NA)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(devtools)
library(netify)
suppressMessages(library(netify))
library(peacesciencer)
library(tidyverse)
# create a dyadic data set (MIDS, high NA)
conf_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2015)) %>%
# set data to politically relevant dyads
filter_prd() %>%
# add conflict GML-MID data
add_gml_mids(keep = NULL)
# create dyadic data set (NGOs)
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2015)) %>%
add_igos()
peek(event_mat, 10)
peek(igo_network, 10)
igo_network <- netify(
igo_dyads,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network
peek(igo_network, 10)
igo_dyads_slice <- igo_dyads %>%
filter(year == 2010)
# time slice
igo_network_2010 <- netify(
igo_dyads_slice,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network_2010
# note:  aggregate ? How can we (should we?) be able to quickly turn something like this binary? review repeating dyads framework again.
igo_network_time_actors <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=FALSE,
weight="dyadigos", symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time_actors
sum_event_mat <- summary(igo_network)
sum_event_mat
transitivity = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
trans <- sum(diag(E%*%t(E)%*%E))/( sum(diag(D%*%t(D)%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(trans)
}
cycles = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
cycles <- sum(diag(E%*%E%*%E))/( sum(diag(D%*%D%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(cycles)
}
sum_event_mat <- summary(event_mat, cycles=cycles, transitivity=transitivity)
sum_event_mat <- summary(igo_network, cycles=cycles, transitivity=transitivity)
sum_event_mat
network_sum <- summary_actor(igo_network)
network_sum
# note: needs another look
nets_time_sum <- summary(igo_network_time)
igo_network_time <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=TRUE,
weight='dyadigos', symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time
# note: needs another look
nets_time_sum <- summary(igo_network_time)
library(ggplot2)
plot_networkStats(nets_time_sum, longitudinal = TRUE, net_stat=c("sdSendEff", "sdRecEff")) +
labs(title = "Network-level Statistics") +
theme_bw()
library(ggplot2)
plot_networkStats(nets_time_sum, longitudinal = TRUE, net_stat=c("sdSendEff", "sdRecEff")) +
labs(title = "Network-level Statistics") +
theme_bw()
library(devtools)
library(netify)
suppressMessages(library(netify))
library(peacesciencer)
library(tidyverse)
# create a dyadic data set (MIDS, high NA)
conf_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
# set data to politically relevant dyads
filter_prd() %>%
# add conflict GML-MID data
add_gml_mids(keep = NULL)
# create dyadic data set (NGOs)
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
add_igos()
netify(
dyad_data,
actor1=NULL, actor2=NULL, time=NULL,
symmetric=TRUE,
mode='unipartite',
weight=NULL,
sum_dyads=TRUE,
actor_time_uniform=TRUE,
actor_pds=NULL,
diag_to_NA=TRUE,
missing_to_zero=TRUE,
output_format = ifelse(is.null(time), "cross_sec", "longit_list"),
nodal_vars=NULL,dyad_vars=NULL, dyad_vars_symmetric=NULL
)
igo_network <- netify(
igo_dyads,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network
peek(igo_network, 10)
igo_dyads_slice <- igo_dyads %>%
filter(year == 2010)
# time slice
igo_network_2010 <- netify(
igo_dyads_slice,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network_2010
# note:  aggregate ? How can we (should we?) be able to quickly turn something like this binary? review repeating dyads framework again.
igo_network_time <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=TRUE,
weight='dyadigos', symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time
# use the index location
peek(igo_network_time, when_to_peek = 2)
igo_network_time_actors <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=FALSE,
weight="dyadigos", symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time_actors
head(lapply(igo_network_time_actors, dim))
is.list(igo_network_time_actors)
# cross sectional peek
peek(igo_network_2010)
# changing actors peek
peek(igo_network_time_actors, when_to_peek = 5, what_to_peek = 10 )
sum_event_mat <- summary(igo_network)
sum_event_mat
transitivity = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
trans <- sum(diag(E%*%t(E)%*%E))/( sum(diag(D%*%t(D)%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(trans)
}
cycles = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
cycles <- sum(diag(E%*%E%*%E))/( sum(diag(D%*%D%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(cycles)
}
sum_event_mat <- summary(igo_network, cycles=cycles, transitivity=transitivity)
sum_event_mat
network_sum <- summary_actor(igo_network)
network_sum
# note: needs another look
nets_time_sum <- summary(igo_network_time)
library(ggplot2)
plot_networkStats(nets_time_sum, longitudinal = TRUE, net_stat=c("sdSendEff", "sdRecEff")) +
labs(title = "Network-level Statistics") +
theme_bw()
# compare USA (2), China (710), Russia (365)
plot_actorStats(network_sum, longitudinal=FALSE, net_stat=c('average_degree_in','average_degree_out'),
actor_names=c('2', '710', '365'), toplist_n=NULL)
plot_actorStats(network_sum, longitudinal=FALSE, net_stat='average_degree_in', toplist_n=10)
# select actors for graphing, regenerate data to do so (and remake netlet)?
# what is the easiest way to subset a netlet?
# test <- igo_network_2010[1:20, 1:20]
# class(test)
igraph_obj <- prep_for_igraph(igo_network_2010)
igraph_obj
rm_iso = which(degree(igraph_obj)==0)
library(igraph)
# select actors for graphing, regenerate data to do so (and remake netlet)?
# what is the easiest way to subset a netlet?
# test <- igo_network_2010[1:20, 1:20]
# class(test)
igraph_obj <- prep_for_igraph(igo_network_2010)
igraph_obj
rm_iso = which(degree(igraph_obj)==0)
igraph_obj = delete.vertices(igraph_obj, rm_iso)
graph_attr(igraph_obj, "layout") <- layout.random
plot(igraph_obj, edge.arrow.size=.1,vertex.label=NA)
# select actors for graphing using peek()
net_plot <- peek(igo_network_2010, 20)
net_plot
dim(peek)
dim(net_plot)
library(igraph)
# select actors for graphing using peek()
net_plot <- peek(igo_network_2010, 20)
igraph_obj <- prep_for_igraph(net_plot)
?peek
igraph_obj <- prep_for_igraph(peek(igo_network_2010, 20))
class(net_plot)
net_plot
net_plot
?peek
igo_network$layer
?netify
?create_dyadyears
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
# all dyad-years where any state is a major power
cow_ddy %>% add_cow_majors() %>%
filter(cowmaj1 ==1 | cowmaj2 ==1) %>%
add_igos()
library(peacesciencer)
library(tidyverse)
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
# all dyad-years where any state is a major power
cow_ddy %>% add_cow_majors() %>%
filter(cowmaj1 ==1 | cowmaj2 ==1) %>%
add_igos()
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
# all dyad-years where any state is a major power
add_cow_majors() %>%
filter(cowmaj1 ==1 | cowmaj2 ==1) %>%
add_igos()
head(igo_dyads)
table(igo_dyads$cowmaj1)
igo_network <- netify(
igo_dyads,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE,
nodal_vars = 'cowmaj1')
igo_network
?add_nodal
igo_dyads
igo_dyads <- create_dyadyears(directed = TRUE,
subset_years = c(2010:2014)) %>%
# igos
add_igos() %>%
# min distance dyad
add_minimum_distance()
igo_dyads
add_dyad
?add_dyad
igo_network <- add_nodal(
netlet = igo_network,
dyad_data = igo_dyads,
actor1= 'ccode1',
actor2- 'ccode2',
dyad_vars = 'mindist',
dyad_vars_symmetric = TRUE
)
igo_network <- add_dyad(
netlet = igo_network,
dyad_data = igo_dyads,
actor1= 'ccode1',
actor2- 'ccode2',
dyad_vars = 'mindist',
dyad_vars_symmetric = TRUE
)
igo_network <- add_dyad(
netlet = igo_network,
dyad_data = igo_dyads,
actor1= 'ccode1',
actor2= 'ccode2',
dyad_vars = 'mindist',
dyad_vars_symmetric = TRUE
)
igo_network
# add dyadic variable
igo_network <- add_dyad(
netlet = igo_network,
dyad_data = igo_dyads,
actor1= 'ccode1',
actor2= 'ccode2',
dyad_vars = 'mindist',
dyad_vars_symmetric = TRUE
)
igo_network
peek(igo_network, 10)
igo_dyads_slice <- igo_dyads %>%
filter(year == 2010)
# time slice
igo_network_2010 <- netify(
igo_dyads_slice,
actor1='ccode1', actor2='ccode2',
weight='dyadigos', sum_dyads=TRUE, symmetric=FALSE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
igo_network_2010
# note:  aggregate ? How can we (should we?) be able to quickly turn something like this binary? review repeating dyads framework again.
igo_network_time <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=TRUE,
weight='dyadigos', symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time
igo_network_time
# use the index location
peek(igo_network_time, when_to_peek = 2)
peek(igo_network_time, when_to_peek = `2011`)
?peek
peek(igo_network_time, when_to_peek = c('2010', '2011')
)
igo_network_time_actors <-
netify(
igo_dyads,
actor1="ccode1",actor2= "ccode2",
time = "year",
actor_time_uniform=FALSE,
weight="dyadigos", symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE )
igo_network_time_actors
head(lapply(igo_network_time_actors, dim))
# cross sectional peek
peek(igo_network_2010)
# changing actors peek
peek(igo_network_time_actors, when_to_peek = 5, what_to_peek = 10 )
sum_event_mat <- summary(igo_network)
sum_event_mat
transitivity = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
trans <- sum(diag(E%*%t(E)%*%E))/( sum(diag(D%*%t(D)%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(trans)
}
cycles = function(mat){
E <- mat-mean(mat,na.rm=TRUE)
D <- 1*(!is.na(E))
E[is.na(E)] <- 0
cycles <- sum(diag(E%*%E%*%E))/( sum(diag(D%*%D%*%D))*sd(c(mat),na.rm=TRUE)^3)
return(cycles)
}
sum_event_mat <- summary(igo_network, cycles=cycles, transitivity=transitivity)
sum_event_mat
network_sum <- summary_actor(igo_network)
network_sum
# note: needs another look
nets_time_sum <- summary(igo_network_time)
library(ggplot2)
plot_networkStats(nets_time_sum, longitudinal = TRUE, net_stat=c("sdSendEff", "sdRecEff")) +
labs(title = "Network-level Statistics") +
theme_bw()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(devtools)
library(netify)
suppressMessages(library(netify))
library(peacesciencer)
library(tidyverse)
# create dyadic data set over time
cow_dyads <- create_dyadyears(
subset_years = c(1995:2014)
) %>%
# add mids
add_cow_mids() %>%
# add capital distance
add_capital_distance() %>%
# add democracy
add_democracy()
mid_network <- netify(
cow_dyads,
actor1='ccode1', actor2='ccode2',
weight='cowmidonset',
sum_dyads=TRUE, symmetric=TRUE,
diag_to_NA=TRUE, missing_to_zero=TRUE)
mid_network
peek(mid_network, 20)
peek(mid_network, 3:30)
