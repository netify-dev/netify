---
title: "Netify Workshop"
author: "Cassy Dorff and Shahryar Minhas"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Netify Workshop}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##  Package Overview 

This vignette provides a high level overview of our package from start to finish. The best use of this vignette is to introduce the main components of the package to larger audiences. This overview covers our primary functions with data examples and minimal writing. 

`netify` goals: 

  (1) Create: Netify your data! We Make it easy for users to create networks from raw data in $R$ as well as add additional features, such as nodal and dyadic variables, to the network object.
  (2) Explore: Explore characteristics of the network you created, like summary statistics at both the network and actor levels. Visualize your network.
  (3) Advance:  Advance your network analysis to the next stage by preparing it for use in other network packages and modeling approaches. 
  
`netify` provides a suite of primary functions to help achieve these goals:

| Createüí°  | Explore üîé | Advance Ô∏èüöÄ|
|---------|---------|---------|
| `netify()`  | `peek()`  | `prep_for_amen()`  |
| `add_nodal()` | `summary()`   | `prep_for_igraph()`  |
| `add_dyad()`  | `summary_actor()`  | `prep_for_network()`  |
| `subset_netlet()`  | `plot_actorStats()`  |   | 
|              |   `plot.netify()`|        |

`netify` can take dyadic data or edgelists to get started. 

- The package can also create different types of networks including:

  - cross sectional networks (with static and varying actor composition)
  - longitudinal 
  - bipartite networks
  - multilayer

- As well as create networks with different edge types:
  - weighted 
  - binary 
  - symmetric or non-symmetric 

## Step 1: Create üí°

Begin by loading packages and supplying the data.


```{r, eval=TRUE, results='hide', warning=FALSE, message=FALSE}
# load packages
library(netify)

# install extra packages for this vignette
if('tidyverse' %in% rownames(installed.packages())){
if('peacesciencer' %in% rownames(installed.packages())){
  install.packages('peacesciencer', repos='https://cloud.r-project.org') }
}
# load necessary packages for this vignette
library(peacesciencer)
library(tidyverse)

# organize external data for peacesciencer
peacesciencer::download_extdata()

# create dyadic data set over time using peacesciencer
cow_dyads <- create_dyadyears( 
     subset_years = c(1995:2014)
     ) %>%
    # add mids
    add_cow_mids() %>%
    # add capital distance
    add_capital_distance() %>%
    # add democracy
    add_democracy() %>%
    # add gdp
    add_sdp_gdp()
```

Next, create a `netlet` object from the above COW data frame using our package's core function `netify.` There are a number of useful parameters, but the most important ones to highlight are:

- `dyad_data` is a dyadic data.frame that should have at least the following variables used to specify actors:

  - `actor1`: character indicating actor 1 variable in the data
  - `actor2`: character indicating actor 2 variable in the data
  
- `netify_type` is a type of netlet object (`cross-sec`, `longit_list`, or `longit_array`).

```{r, eval=TRUE}
mid_long_network <- netify(
  cow_dyads,
  actor1='ccode1', actor2='ccode2', time='year',
  weight='cowmidonset', 
  actor_time_uniform=FALSE,
  sum_dyads=FALSE, symmetric=TRUE,
  diag_to_NA=TRUE, missing_to_zero=FALSE,
  nodal_vars = c('v2x_polyarchy1', 'v2x_polyarchy2'),
  dyad_vars = c('capdist'),
  dyad_vars_symmetric = c(TRUE, FALSE)
  )
```

**Congratulations** you have created a network object! üéâ

We can also add nodal and dyadic data after we've created the network via the `add_nodal()` and `add_dyad()` functions. 

Let's assume that we had information about each actor in the network that we'd like to add as a nodal variable after we already made the network object. This could be from our original data set or elsewhere. For example, lets add a logged variable measuring gdp for each node in the network over time:

```{r, eval=TRUE}
# create a vector of nodal data
node_data <- unique(cow_dyads[,c("ccode1", "year", "wbgdppc2011est2")])
node_data$wbgdppc2011est2_log <- log(node_data$wbgdppc2011est2)

# add nodal variable to netlet object
mid_long_network <- add_nodal(
    netlet = mid_long_network,
    node_data = node_data,
    actor = "ccode1",
    time = "year"
)
```

## Step 2: Explore üîé

We made a network, so let's look at it. First, we might want to take a `peek` at the network object to see if the matrix looks the way we'd expect it to look. This function lets you glance at a specific slice of the network if it is longitudinal or the entire network if it is cross-sectional.

```{r}
peek(mid_long_network, when_to_peek = c('2012'), what_to_peek = 30)
```

Next, let's examine a few basic summary statistics about the network using our`summary()` function.

```{r}
# create data.frame that provides network-level summary stats 
# for each year of the network
mid_long_summary <- summary(mid_long_network)
```

We can also make a quick visualization of network statistics over time using the summary statistics data frame.

```{r, fig.width=6, fig.height=6}
plot_networkStats(mid_long_summary,
                  longitudinal = TRUE,
                  net_stat = "dens") 
```

We might also want to look at a specific set of actors' statistics overtime. Our built-in function, `summary_actor` will calculate in-degree, out-degree, average degree, and eigenvector centrality for each actor in each time period.

```{r}
# every year & every actor (messy!)
summary_actor_mids <- summary_actor(mid_long_network)
```

```{r, fig.width=6, fig.height=6}
# top 5 GDP countries (USA, China, Japan, Germany, India)
top_5 <- c("2", "710", "740", "255", "750")

# zoom in on specific parts of the network for actor viz
mid_subset <- summary_actor_mids %>%
              filter(actor %in% top_5)

plot_actorStats(mid_subset, 
                net_stat = "degree",
                longitudinal = TRUE) +
                facet_wrap(~actor)
```

Instead of looking at summary statistics, we also might want to simply visualize the entire network. We can do this by plotting the netify object. Or we can first subset the object so that we plot only select time periods. (Isolates removed by default).

```{r, fig.width=6, fig.height=6}

# default plot
plot.netify(mid_long_network)

# a little cleaner
plot(
    mid_long_network,
    edge_color='grey',
    node_size=2
)
```

We can also use `netify` functions to explore actor level summary statistics in the network graph. 

```{r}
# add actor variables
mid_long_network = add_nodal(
    mid_long_network, 
    summary_actor(mid_long_network),
    actor='actor', time='time',
    node_vars = c('degree', 'prop_ties', 'eigen_vector'),
)

# vary node size by degree
plot(
    mid_long_network,
    edge_color='grey',
    node_size_var='degree'
)

# vary node color by polyarchy
plot(
    mid_long_network,
    edge_color='grey',
    node_size_var='degree',
    node_color_var='v2x_polyarchy1'
    ) + 
    scale_color_gradient2()
```

We might also prefer to add labels, but only a select few:

```{r}
library(countrycode)
cowns = countrycode(
    c('United States', 'China', 'Russia', 'France', 'Germany', 'United Kingdom'), 
    'country.name', 'cown')
cabbs = countrycode(cowns, 'cown', 'iso3c')

plot(
    mid_long_network,
    edge_color='grey',
    node_size_var='degree',
    node_color_var='v2x_polyarchy1',
    select_text = cowns,
    select_text_display = cabbs,
    text_size = 5
    ) + 
    scale_color_gradient2()

plot(
    mid_long_network,
    edge_color='grey',
    add_points = FALSE, 
    add_label = TRUE,
    label_size_var='degree',
    label_color = 'white',
    label_fill_var='v2x_polyarchy1'
    ) + 
    scale_color_gradient2()
```

## Step 3: Advance üöÄ

Once we have created and explored our network object, we might want to continue analyzing the data using different modeling approaches. `netify` makes this simple!

```{r}
# install (if necessary) and load amen
if('amen' %in% rownames(installed.packages())){
  install.packages('amen', repos='https://cloud.r-project.org') }
library(amen)

# install (if necessary) and load ergm
if('ergm' %in% rownames(installed.packages())){
  install.packages('ergm', repos='https://cloud.r-project.org') }
library(ergm)

# lets take a cross-section of the network object

```

### Bonus Examples

A common data type used to create networks is in the structure of event data, where actors are repeated across rows but there is no specific variable that denotes the 'edge' as shown in our previous example.

We show how to use `netify` and UCDP data as just one example of potential applications to intrastate event data. The first step is to go to https://ucdp.uu.se/downloads/ and download the data you want to use. For this tutorial we have downloaded UCDP GED event data version 23.1 and subset the data for the case of Mexico. 

UCDP Data Citations:

-  Davies, Shawn, Therese Pettersson & Magnus √ñberg (2023). Organized violence 1989-2022 and the return of conflicts between states?. Journal of Peace Research 60(4).

- Sundberg, Ralph and Erik Melander (2013) Introducing the UCDP Georeferenced Event Dataset. Journal of Peace Research 50(4).

-  H√∂gbladh Stina, 2023, ‚ÄúUCDP GED Codebook version 23.1‚Äù, Department of Peace and Conflict Research, Uppsala University

```{r}
load("ucdp_ged_mexico.rda")
```

(1) Create an aggregated, weighted network of conflict between actors in Mexico. 

```{r}
# default to number of events
mex_network <- netify(
  dyad_data = mexico,
  actor1 = 'side_a',
  actor2 = 'side_b',
  symmetric = TRUE,
  sum_dyads = TRUE,
  diag_to_NA = TRUE,
  missing_to_zero = TRUE
)

# A summary of the network object
summary(mex_network)

# weight using a variable
mex_network_civ <- netify(
  dyad_data = mexico,
  actor1 = 'side_a',
  actor2 = 'side_b',
  weight = 'deaths_civilians',
  symmetric = TRUE,
  sum_dyads = TRUE,
  diag_to_NA = TRUE,
  missing_to_zero = TRUE
)

summary(mex_network_civ)
```

(2) Explore

```{r, fig.width=6, fig.height=6}
# select 10 random indices from 1 to the length of select_names
select_names <- rownames(mex_network)

set.seed(12345)
random_indices <- sample(length(select_names), 10)

# select 10 random names using the random indices
random_names <- select_names[random_indices]

plot(mex_network,
     add_text = TRUE)
    
plot(mex_network,
     select_text = random_names,
     select_text_display = random_names)

# different edges, highlight same actors, different netify object:
plot(mex_network_civ,
     select_text = random_names,
     select_text_display = random_names)
```

We can also apply functions from `igraph`:

```{r}
library(igraph)
i_close = function(x){ ig = prep_for_igraph(x) ; igraph::closeness(ig) }
closeness = i_close(mex_network)

# add to summary
sum_mex <- summary_actor(mex_network, other_stats = list(closeness=closeness))
```